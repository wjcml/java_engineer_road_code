## java的三种代理模式
关于java静态代理，JDK动态代理和cglib动态代理的代码

### 1、Java版本： JDK 1.8

### 2、依赖：
**依赖的子模块**  
[spring_swagger](./spring_swagger)

**其他的依赖**
```xml
        <!-- cglib 依赖 -->
        <!-- 如果你已经有spring-core的jar包，则无需引入，因为spring中包含了cglib -->
        <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.2.5</version>
        </dependency>
```

### 3、三种代理
##### 3.1 静态代理和动态代理
**静态代理**：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。  
**动态代理**：动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中。  

##### 3.2 静态代理
```text
静态代理方式需要代理对象和目标对象实现同一个的接口  
缺点：冗余，不宜维护
```
##### 3.3 JDK动态代理（也称为接口代理）
```text
JDK动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理  
JDK动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活
```

##### 3.4 cglib动态代理
```text
cglib包的底层是通过使用一个小而快的字节码处理框架ASM(什么是ASM？)，来转换字节码并生成新的类。  
cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。
```

**注意**：
```text
cglib与JDK动态代理最大的区别就是JDK动态代理的对象必须实现一个或多个接口，使用cglib代理的对象则无需实现接口。  
JDK动态代理：代理的是接口  
cglib代理：代理的是类
```

##### 什么是ASM框架？

*ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。*

*ASM 能够通过改造既有类，直接生成需要的代码。增强的代码是硬编码在新生成的类文件内部的，没有反射带来性能上的付出。同时，ASM 与 Proxy 编程不同，不需要为增强代码而新定义一个接口，生成的代码可以覆盖原来的类，或者是原始类的子类。它是一个普通的 Java 类而不是 proxy 类，甚至可以在应用程序的类框架中拥有自己的位置，派生自己的子类。*

*相比于其他流行的 Java 字节码操纵工具，ASM 更小更快。ASM 具有类似于 BCEL 或者 SERP 的功能，而只有 33k 大小，而后者分别有 350k 和 150k。同时，同样类转换的负载，如果 ASM 是 60% 的话，BCEL 需要 700%，而 SERP 需要 1100% 或者更多。*


